// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package sqlitestore

import (
	"context"
)

const checkBlockExists = `-- name: CheckBlockExists :one
SELECT EXISTS(SELECT 1 FROM blocks WHERE number = ? AND hash = ?)
`

type CheckBlockExistsParams struct {
	Number int64  `json:"number"`
	Hash   []byte `json:"hash"`
}

func (q *Queries) CheckBlockExists(ctx context.Context, arg CheckBlockExistsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkBlockExists, arg.Number, arg.Hash)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const deleteBlocksFrom = `-- name: DeleteBlocksFrom :execrows
DELETE FROM blocks WHERE number >= ?
`

func (q *Queries) DeleteBlocksFrom(ctx context.Context, number int64) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteBlocksFrom, number)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteBlocksRange = `-- name: DeleteBlocksRange :exec
DELETE FROM blocks WHERE number >= ? AND number <= ?
`

type DeleteBlocksRangeParams struct {
	Number   int64 `json:"number"`
	Number_2 int64 `json:"number_2"`
}

func (q *Queries) DeleteBlocksRange(ctx context.Context, arg DeleteBlocksRangeParams) error {
	_, err := q.db.ExecContext(ctx, deleteBlocksRange, arg.Number, arg.Number_2)
	return err
}

const getBlockByNumber = `-- name: GetBlockByNumber :one
SELECT number, hash, parent, block, receipts, call_traces, prestate_traces, keccak256_preimage_traces, state_access_traces
FROM blocks
WHERE number = ?
`

func (q *Queries) GetBlockByNumber(ctx context.Context, number int64) (Block, error) {
	row := q.db.QueryRowContext(ctx, getBlockByNumber, number)
	var i Block
	err := row.Scan(
		&i.Number,
		&i.Hash,
		&i.Parent,
		&i.Block,
		&i.Receipts,
		&i.CallTraces,
		&i.PrestateTraces,
		&i.Keccak256PreimageTraces,
		&i.StateAccessTraces,
	)
	return i, err
}

const getBlockCount = `-- name: GetBlockCount :one

SELECT COUNT(*) FROM blocks
`

// Queries for reorgqueue package
func (q *Queries) GetBlockCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getBlockCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getBlockHashByNumber = `-- name: GetBlockHashByNumber :one
SELECT hash
FROM blocks
WHERE number = ?
`

func (q *Queries) GetBlockHashByNumber(ctx context.Context, number int64) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, getBlockHashByNumber, number)
	var hash []byte
	err := row.Scan(&hash)
	return hash, err
}

const getBlocks = `-- name: GetBlocks :many
SELECT number, hash, parent, block, receipts, call_traces, prestate_traces, keccak256_preimage_traces, state_access_traces
FROM blocks
ORDER BY number ASC
LIMIT ?
`

func (q *Queries) GetBlocks(ctx context.Context, limit int64) ([]Block, error) {
	rows, err := q.db.QueryContext(ctx, getBlocks, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Block
	for rows.Next() {
		var i Block
		if err := rows.Scan(
			&i.Number,
			&i.Hash,
			&i.Parent,
			&i.Block,
			&i.Receipts,
			&i.CallTraces,
			&i.PrestateTraces,
			&i.Keccak256PreimageTraces,
			&i.StateAccessTraces,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHighestBlock = `-- name: GetHighestBlock :one
SELECT COALESCE(MAX(number), -1) FROM blocks
`

func (q *Queries) GetHighestBlock(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getHighestBlock)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const getLowestBlock = `-- name: GetLowestBlock :one
SELECT COALESCE(MIN(number), -1) FROM blocks
`

func (q *Queries) GetLowestBlock(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getLowestBlock)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const getTailBlock = `-- name: GetTailBlock :one
SELECT number, hash FROM tail_block WHERE id = 1
`

type GetTailBlockRow struct {
	Number int64  `json:"number"`
	Hash   []byte `json:"hash"`
}

func (q *Queries) GetTailBlock(ctx context.Context) (GetTailBlockRow, error) {
	row := q.db.QueryRowContext(ctx, getTailBlock)
	var i GetTailBlockRow
	err := row.Scan(&i.Number, &i.Hash)
	return i, err
}

const getTopBlocks = `-- name: GetTopBlocks :many
SELECT number, hash, parent 
FROM blocks 
ORDER BY number DESC 
LIMIT ?
`

type GetTopBlocksRow struct {
	Number int64  `json:"number"`
	Hash   []byte `json:"hash"`
	Parent []byte `json:"parent"`
}

func (q *Queries) GetTopBlocks(ctx context.Context, limit int64) ([]GetTopBlocksRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopBlocks, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopBlocksRow
	for rows.Next() {
		var i GetTopBlocksRow
		if err := rows.Scan(&i.Number, &i.Hash, &i.Parent); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertBlock = `-- name: InsertBlock :exec
INSERT INTO blocks (number, hash, parent, block, receipts, call_traces, prestate_traces, keccak256_preimage_traces, state_access_traces)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertBlockParams struct {
	Number                  int64  `json:"number"`
	Hash                    []byte `json:"hash"`
	Parent                  []byte `json:"parent"`
	Block                   []byte `json:"block"`
	Receipts                []byte `json:"receipts"`
	CallTraces              []byte `json:"call_traces"`
	PrestateTraces          []byte `json:"prestate_traces"`
	Keccak256PreimageTraces []byte `json:"keccak256_preimage_traces"`
	StateAccessTraces       []byte `json:"state_access_traces"`
}

func (q *Queries) InsertBlock(ctx context.Context, arg InsertBlockParams) error {
	_, err := q.db.ExecContext(ctx, insertBlock,
		arg.Number,
		arg.Hash,
		arg.Parent,
		arg.Block,
		arg.Receipts,
		arg.CallTraces,
		arg.PrestateTraces,
		arg.Keccak256PreimageTraces,
		arg.StateAccessTraces,
	)
	return err
}

const setTailBlock = `-- name: SetTailBlock :exec
INSERT INTO tail_block (id, number, hash) VALUES (1, ?, ?)
ON CONFLICT(id) DO UPDATE SET number = excluded.number, hash = excluded.hash
`

type SetTailBlockParams struct {
	Number int64  `json:"number"`
	Hash   []byte `json:"hash"`
}

func (q *Queries) SetTailBlock(ctx context.Context, arg SetTailBlockParams) error {
	_, err := q.db.ExecContext(ctx, setTailBlock, arg.Number, arg.Hash)
	return err
}
